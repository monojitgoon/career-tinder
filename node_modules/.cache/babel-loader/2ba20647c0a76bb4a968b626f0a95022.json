{"ast":null,"code":"var closest = function closest(element, selector) {\n  if (element.closest) {\n    return element.closest(selector);\n  }\n\n  var matches = Element.prototype.matches ? function (el, sel) {\n    return el.matches(sel);\n  } : function (el, sel) {\n    return el.msMatchesSelector(sel);\n  };\n  var node = element;\n\n  while (node) {\n    if (matches(node, selector)) {\n      return node;\n    }\n\n    node = node.parentElement;\n  }\n};\n\nvar createRipple = function createRipple(doc) {\n  var ripple = doc.createElement('div');\n  ripple.className = 'k-ripple';\n  var blob = doc.createElement('div');\n  blob.className = 'k-ripple-blob';\n  ripple.appendChild(blob);\n  return [ripple, blob];\n};\n\nvar once = function once(element, eventName, fn) {\n  var listener = function listener() {\n    fn();\n    element.removeEventListener(eventName, listener, false);\n  };\n\n  var remove = function remove() {\n    return element.addEventListener(eventName, listener, false);\n  };\n\n  remove();\n  return {\n    remove: remove\n  };\n};\n\nvar activate = function activate(containerSelector, options) {\n  return function (e) {\n    var target = e.target;\n    var doc = target.document || target.ownerDocument;\n    var container;\n\n    if (options.container) {\n      container = options.container(target);\n    } else {\n      container = closest(target, containerSelector);\n    }\n\n    if (!container) {\n      return;\n    } // focus event of ripple container triggers double-focus\n\n\n    var doubleFocus = /focus/i.test(e.type) && container.classList.contains(\"k-ripple-target\");\n\n    if (doubleFocus) {\n      return;\n    } // suppress focus when animating ripples\n\n\n    container.classList.add(\"k-ripple-target\");\n\n    var _a = createRipple(doc),\n        ripple = _a[0],\n        blob = _a[1];\n\n    var state = {\n      animated: false,\n      released: false,\n      blob: blob,\n      container: container,\n      ripple: ripple\n    };\n    var eventType = {\n      'focusin': 'focusout',\n      'keydown': 'keyup',\n      'mousedown': 'mouseup',\n      'pointerdown': 'pointerup',\n      'touchdown': 'touchup'\n    }[e.type];\n    once(e.currentTarget, eventType, function () {\n      return release(state);\n    });\n    container.appendChild(ripple); // recalc to allow the effect to animate\n\n    window.getComputedStyle(ripple).getPropertyValue('opacity');\n    var rect = container.getBoundingClientRect();\n    var left = 0;\n    var top = 0;\n\n    if (/mouse|pointer|touch/.test(e.type)) {\n      left = e.clientX - rect.left;\n      top = e.clientY - rect.top;\n    } else {\n      left = rect.width / 2;\n      top = rect.height / 2;\n    } // coordinates of the farthest corner\n\n\n    var xMax = left < rect.width / 2 ? rect.width : 0;\n    var yMax = top < rect.height / 2 ? rect.height : 0; // distance to the farthest corner\n\n    var dx = left - xMax;\n    var dy = top - yMax; // blob size is twice the blob radius\n\n    var size = 2 * Math.sqrt(dx * dx + dy * dy);\n    var duration = 500;\n    blob.style.width = blob.style.height = size + \"px\"; // force reflow for Safari 11 to align ripple blob\n\n    if (blob.offsetWidth < 0) {\n      throw new Error(\"Inconceivable!\");\n    }\n\n    blob.style.cssText = \"\\n    width: \" + size + \"px;\\n    height: \" + size + \"px;\\n    transform: translate(-50%, -50%) scale(1);\\n    left: \" + left + \"px;\\n    top: \" + top + \"px;\\n  \";\n    setTimeout(function () {\n      return finishAnimation(state);\n    }, duration);\n  };\n};\n\nvar finishAnimation = function finishAnimation(state) {\n  state.animated = true;\n  deactivate(state);\n};\n\nvar release = function release(state) {\n  state.released = true;\n  deactivate(state);\n};\n\nvar deactivate = function deactivate(state) {\n  // deactivation happens when both\n  // - the activation event has been released (release)\n  // - the ripple has finished animating (finishAnimation)\n  if (!state.released || !state.animated) {\n    return;\n  }\n\n  var blob = state.blob,\n      ripple = state.ripple,\n      container = state.container;\n\n  if (container) {\n    once(container, 'blur', function () {\n      return container.classList.remove(\"k-ripple-target\");\n    });\n  }\n\n  if (blob) {\n    once(blob, 'transitionend', function () {\n      if (ripple && ripple.parentNode) {\n        ripple.parentNode.removeChild(ripple);\n      }\n    });\n    blob.style.transition = 'opacity 200ms linear';\n    blob.style.opacity = '0';\n  }\n};\n/**\n * @hidden\n */\n\n\nexport var register = function register(root, elements) {\n  var flatten = function flatten(arr) {\n    return [].concat.apply([], arr);\n  };\n\n  var handlers = flatten(elements.map(function (item) {\n    var defaultOptions = {\n      events: ['mousedown', 'touchdown'],\n      global: false\n    };\n    var selector = item.selector,\n        _a = item.options,\n        options = _a === void 0 ? defaultOptions : _a;\n    var activator = activate(selector, options);\n    var events = options.events || defaultOptions.events;\n    var container = options.global ? document.body : root;\n    events.forEach(function (evt) {\n      return container.addEventListener(evt, activator, false);\n    });\n    return {\n      events: events,\n      options: options,\n      activator: activator\n    };\n  }));\n  return function () {\n    if (!root) {\n      return;\n    }\n\n    var removeListener = function removeListener(_a) {\n      var events = _a.events,\n          options = _a.options,\n          activator = _a.activator;\n      var container = options.global ? document.body : root;\n      events.forEach(function (evt) {\n        return container.removeEventListener(evt, activator, false);\n      });\n    };\n\n    handlers.forEach(removeListener);\n    root = null;\n  };\n};","map":null,"metadata":{},"sourceType":"module"}